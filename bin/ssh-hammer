#!/usr/bin/env ruby 

require "uri"
require "highline/import"
require "em-ssh"
require "em-ssh/shell"

class Passwords
  class << self
    def get(*path)
      path     = path.flatten
      file_key = path.join(".")
      return password if (password = ENV[path.join"_"])
      [File.expand_path("~/.passwords"), "/etc/passwords"].each do |dir|
        pfile = File.join(dir, file_key)
        next unless File.exists?(pfile)
        password = IO.read(pfile).chomp
        return password.chomp if password
      end #  |dir|
      
      if STDIN.tty?
        password = ask("What is #{path} password? "){|q| q.echo = "*" }
      end 
      return password
    end 
  end # << self
end # class::Passwords




class Crasher
  include EM::Deferrable
  def initialize(uri, wait_str, opts = {})
    opts      = {:pause => 0.5, :timeout => 10, :min_retries => 5}.merge(opts)
    opts.each{|k,v| self.instance_variable_set("@#{k}".intern, v)}
    @uri      = uri
    @wait_str = wait_str
    @session_cnt   = 0
    @tries         = 5
    @retry_pause ||= @pause * 5
    Fiber.new { yield self }.resume if block_given?
  end 


  def sleep(t = @pause)
    f = Fiber.current
    EM::Timer.new(t) { f.resume }
    Fiber.yield
  end

  def hammer
    @start = Time.new
    start_hammers
    EM::PeriodicTimer.new(2) do
      print "#{stat}"
    end
  end 

  def stat
    "\r#{' ' * 120}\r#{@session_cnt} sessions (#{@hammers}/#{@concurrency}) @#{@start && elapsed(@start)} minutes "
  end # stat

  def elapsed(since)
    ((Time.new - since) / 60).round(2)
  end 

  def start_hammers
    concurrency   = max_concurrency
    @concurrency  = concurrency
    @session_cnt += concurrency
    @hammers      = concurrency
    print "\r#{stat} switch concurrency is #{concurrency} "
    concurrency.times do |i|
      Fiber.new { 
        verify(i)
        @hammers -= 1
        if @hammers <= 0
          EM::Timer.new(@pause) { Fiber.new { start_hammers }.resume } 
        end 
      }.resume
      sleep(@pause)
    end
    
    if concurrency == 0
      @tries -= 1
      if @tries > 0
        open? do |is_open|
          if is_open
            puts "concurrency is at 0, but port 22 appears to be open; retrying up to #{@tries} times in #{@retry_pause}s"
            EM::Timer.new(@retry_pause)
          else
            succeed(@session_cnt)
          end 
        end
      end 
    end
  end


  def verify(id)
    f = Fiber.current
    EM::Ssh::Shell.new(@uri.host, @uri.user, @uri.password, :timeout => @timeout, :reconnect => false, :net_ssh => {:nego_timeout => 2}) do |shell|
      shell.errback do |e| 
        print "*"
        f.resume(false) 
      end
      shell.callback do
        e = false
        begin
          shell.expect(@wait_str)
          @session_cnt += 1
          shell.expect(@wait_str, "show version\n")
          shell.send_data("exit\n")
          print "."
          shell.close
          shell.connection.close_connection
        rescue => e
          print "*"
        end
        f.resume(!!!e)
      end
    end
    Fiber.yield
  end # verify(id)

  def open?(timeout = 5, &blk)
    return unless block_given?
    work = lambda do
      begin
        Timeout.timeout(timeout || 5) { sock  = TCPSocket::new(@uri.host, 22) } 
      rescue Timeout::Error => e
        return false
      rescue Errno::ECONNREFUSED => e
        return false
      rescue Errno::EHOSTDOWN => e
        return false
      ensure
        sock.close if sock.respond_to?(:close)
      end 
    end
    EM.defer(work, &blk)
  end

  def max_connections
    f      = Fiber.current
    cnt    = 0
    shells = []
    timer  = EM::PeriodicTimer.new(1) do
      EM::Ssh::Shell.new(@uri.host, @uri.user, @uri.password, :timeout => @timeout, :net_ssh => {:nego_timeout => 2}) do |shell|
        shell.errback { |e| print "*" }
        shell.callback do
          shells << shell
          begin
            shell.expect(@wait_str)
            cnt += 1
            shell.expect(@wait_str, "show version\n")
            print "."
          rescue => e
            print "*"
          end
        end
      end
    end

    EM::PeriodicTimer.new(5) do
      open? do |is_open|
        unless is_open
          timer && timer.cancel
          shells.each do |s|
            s.close
            s.connection.close_connection
          end
          f.resume(cnt)
        end
      end
    end

    Fiber.yield
  end

  def max_concurrency
    f = Fiber.current
    cnt      = 0
    finished = false
    shells   = []
    timer    = nil
    done = lambda do |e|
      return if finished
      finished = true
      timer && timer.cancel
      print "#{stat} max concurrent connections is #{cnt} "
      shells.each do |s| 
        s.send_data("exit\n") 
        s.close
        s.connection.close_connection
      end
      f.resume(cnt)
    end

    print "#{stat} determining max concurrent connections "
    timer = EM::PeriodicTimer.new(1) do
      EM::Ssh::Shell.new(@uri.host, @uri.user, @uri.password, :timeout => @timeout, :net_ssh => {:nego_timeout => 2}) do |shell|
        shell.callback do
          shells << shell
          print "-"
          begin
            shell.expect(@wait_str)
            cnt += 1
            shell.expect(@wait_str, "show version\n")
            print "+"
          rescue => e
            done[e]
          end
        end
        shell.errback { |e| done[e] }
      end
    end
    Fiber.yield
  end 
end

wait_str = "Dev-BS2(TEST)# "
options  = {}
opts = OptionParser.new
opts.on('-p', '--prompt String', String, "prompt to expect after login default: #{wait_str.inspect}") { |w| wait_str = w }
opts.on('-t', '--timeout Integer', Integer, 'number of seconds to wait for the device to open an ssh connection ') {|t| options[:timeout] = t}
opts.on('--pause Decimal', Float, 'number of seconds to wait before establishing a new connection') {|t| options[:pause] = t }
opts.on('--retry-pause Decimal', Float, 'number of seconds to wait before restarting the test after the device appears to have crashed') {|t| options[:retry_pause] = t }
opts.on('-r', '--retries Integer', Integer, 'number of times each thread should retry the connection before giving up') {|r| options[:min_retries] = r }
opts.on('-f', '--find-concurrency', 'determine the current maximum number of concurrent session supported') {  options[:find_concurrency] = true }
opts.on('--open-connections', 'determine number of open connections the device supports') { options[:open_connections] }
opts.banner = opts.banner + " URL"
opts.parse!(ARGV)

wait_str = Regexp.escape(wait_str)

addr_idx = ARGV.index{|i| i.start_with?("ssh://")}
if addr_idx.nil?
  puts "\e[31m ssh:// url expected\e[0m"
  Process.exit  
end 

uri          = URI.parse(ARGV[addr_idx])
uri.user     = "admin" if uri.user.nil?
uri.password = Passwords.get(["switch", uri.host]) if uri.password.nil?
uri.port     = 22 if uri.port.nil?



EM.run do
  #EM::Ssh.logger(::Logger::DEBUG)
  Crasher.new(uri, wait_str, options) do |crasher|
    if options[:find_concurrency]
      puts "\nmax concurrency: #{crasher.max_concurrency}\n\n"
      EM.stop
    elsif options[:open_connections]
      puts "\nmax open connections #{crasher.max_connections}\n\n"
      EM.stop
    else  
      start = Time.new
      crasher.callback do |sessions|
        puts "total sessions #{sessions}"
        puts "total time: #{((Time.new - start) / 60).round(2)} minutes"
        EM.stop
      end
      crasher.hammer
    end 
  end
end
